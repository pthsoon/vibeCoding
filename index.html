<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Tetris — Single File</title>
  <style>
    :root{--bg:#111;--board:#0d0d0d;--panel:#111;--accent:#ffce00}
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,"Helvetica Neue",Arial}
    body{display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,#071020, #071827);color:#e6eef6}
    .wrap{display:grid;grid-template-columns:320px 240px;gap:18px;align-items:start}
    .board-card{background:var(--board);padding:12px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,.6)}
    canvas{display:block;background:linear-gradient(180deg,#071827,#081827);image-rendering:pixelated;border-radius:8px}
    .panel{width:240px;background:var(--panel);padding:14px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,.45)}
    h1{font-size:20px;margin:0 0 8px}
    .info{display:flex;flex-direction:column;gap:8px}
    .row{display:flex;justify-content:space-between;align-items:center}
    .big{font-size:20px;font-weight:700}
    .small{font-size:12px;color:#9fb0c6}
    .controls{margin-top:10px;display:grid;grid-template-columns:1fr 1fr;gap:8px}
    button{background:#16324a;border:0;color:#dff0ff;padding:8px;border-radius:8px;cursor:pointer}
    button.secondary{background:#0c2b2a}
    .nextCanvas{background:#071827;border-radius:6px}
    footer{font-size:12px;color:#9fb0c6;margin-top:10px}
    .hud{display:grid;grid-template-columns:1fr 1fr;gap:8px}
    .stat{background:rgba(255,255,255,0.03);padding:8px;border-radius:8px;text-align:center}
    .center{display:flex;align-items:center;justify-content:center}
    .controls-touch{display:flex;gap:8px;margin-top:10px}
    .controls-touch button{flex:1}
    @media (max-width:740px){body{padding:20px} .wrap{grid-template-columns:1fr} .panel{order:2}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board-card">
      <h1>TETRIS</h1>
      <div class="small">Use arrow keys — ← → move, ↑ rotate, ↓ soft drop, Space hard drop, P pause</div>
      <div style="height:12px"></div>
      <canvas id="board" width="200" height="400"></canvas>
    </div>

    <div class="panel">
      <div class="info">
        <div class="row"><div>Score</div><div class="big" id="score">0</div></div>
        <div class="row"><div>Lines</div><div class="big" id="lines">0</div></div>
        <div class="row"><div>Level</div><div class="big" id="level">1</div></div>
      </div>

      <div style="margin-top:12px">
        <div class="small">Next</div>
        <canvas id="next" width="120" height="120" class="nextCanvas"></canvas>
      </div>

      <div class="hud" style="margin-top:12px">
        <div class="stat"><div class="small">Best</div><div id="best">0</div></div>
        <div class="stat"><div class="small">Status</div><div id="status">PLAY</div></div>
      </div>

      <div class="controls">
        <button id="btnStart">Start / Restart</button>
        <button id="btnPause" class="secondary">Pause</button>
        <button id="btnHold">Hold</button>
        <button id="btnToggleSound">Sound On</button>
      </div>

      <div class="controls-touch">
        <button id="leftBtn">◀</button>
        <button id="downBtn">▼</button>
        <button id="rightBtn">▶</button>
        <button id="rotateBtn">⟳</button>
      </div>

      <footer>Single-file Tetris — open this HTML in any modern browser to play.</footer>
    </div>
  </div>

<script>
(() => {
  // Config
  const COLS = 10, ROWS = 20, BLOCK = 20;
  const boardCanvas = document.getElementById('board');
  const ctx = boardCanvas.getContext('2d');
  boardCanvas.width = COLS * BLOCK; boardCanvas.height = ROWS * BLOCK;
  const nextCanvas = document.getElementById('next');
  const nctx = nextCanvas.getContext('2d');

  // DOM
  const scoreEl = document.getElementById('score');
  const linesEl = document.getElementById('lines');
  const levelEl = document.getElementById('level');
  const bestEl = document.getElementById('best');
  const statusEl = document.getElementById('status');

  const btnStart = document.getElementById('btnStart');
  const btnPause = document.getElementById('btnPause');
  const btnHold = document.getElementById('btnHold');
  const btnToggleSound = document.getElementById('btnToggleSound');

  const leftBtn = document.getElementById('leftBtn');
  const rightBtn = document.getElementById('rightBtn');
  const downBtn = document.getElementById('downBtn');
  const rotateBtn = document.getElementById('rotateBtn');

  // State
  let board = createMatrix(COLS, ROWS);
  let current = null; let next = null; let hold = null; let canHold = true;
  let score = 0, lines = 0, level = 1; let best = localStorage.getItem('tetrisBest')||0;
  let dropCounter = 0, dropInterval = 1000; let lastTime = 0; let playing = false; let paused = false;
  let soundOn = true;

  bestEl.textContent = best;

  // Pieces (tetrominoes)
  const PIECES = {
    I: {color:'#4ade80', shape:[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]]},
    J: {color:'#60a5fa', shape:[[1,0,0],[1,1,1],[0,0,0]]},
    L: {color:'#f59e0b', shape:[[0,0,1],[1,1,1],[0,0,0]]},
    O: {color:'#f97316', shape:[[1,1],[1,1]]},
    S: {color:'#34d399', shape:[[0,1,1],[1,1,0],[0,0,0]]},
    T: {color:'#a78bfa', shape:[[0,1,0],[1,1,1],[0,0,0]]},
    Z: {color:'#f87171', shape:[[1,1,0],[0,1,1],[0,0,0]]}
  };
  const PIECE_KEYS = Object.keys(PIECES);

  function createMatrix(w,h){
    const m = [];
    for(let y=0;y<h;y++){m.push(new Array(w).fill(0));}
    return m;
  }

  function drawSquare(x,y,color){
    ctx.fillStyle = '#051421';
    ctx.fillRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)';
    ctx.strokeRect(x*BLOCK+1, y*BLOCK+1, BLOCK-2, BLOCK-2);
    ctx.fillStyle = color;
    ctx.fillRect(x*BLOCK+2, y*BLOCK+2, BLOCK-4, BLOCK-4);
  }

  function draw(){
    ctx.clearRect(0,0,boardCanvas.width, boardCanvas.height);
    // background grid
    ctx.fillStyle = '#071827';
    ctx.fillRect(0,0,boardCanvas.width, boardCanvas.height);

    for(let y=0;y<ROWS;y++){
      for(let x=0;x<COLS;x++){
        const v = board[y][x];
        if(v){ drawSquare(x,y,v); }
        else { // empty cell subtle grid
          ctx.strokeStyle = 'rgba(255,255,255,0.01)';
          ctx.strokeRect(x*BLOCK, y*BLOCK, BLOCK, BLOCK);
        }
      }
    }

    if(current){
      const {matrix, pos, color} = current;
      for(let y=0;y<matrix.length;y++){
        for(let x=0;x<matrix[y].length;x++){
          if(matrix[y][x]) drawSquare(pos.x + x, pos.y + y, color);
        }
      }
    }
  }

  function createPiece(type){
    const proto = PIECES[type];
    return {matrix: proto.shape.map(row=>row.slice()), pos:{x:Math.floor(COLS/2)-Math.ceil(proto.shape[0].length/2), y:-1}, color:proto.color, type};
  }

  function collide(mat, m){
    for(let y=0;y<m.matrix.length;y++){
      for(let x=0;x<m.matrix[y].length;x++){
        if(m.matrix[y][x]){
          const bx = m.pos.x + x, by = m.pos.y + y;
          if(by<0) continue; // above board allowed
          if(bx<0||bx>=COLS||by>=ROWS) return true;
          if(board[by][bx]) return true;
        }
      }
    }
    return false;
  }

  function merge(){
    for(let y=0;y<current.matrix.length;y++){
      for(let x=0;x<current.matrix[y].length;x++){
        if(current.matrix[y][x]){
          const by = current.pos.y + y;
          if(by>=0) board[by][current.pos.x + x] = current.color;
        }
      }
    }
  }

  function rotate(matrix, dir){
    // transpose
    for(let y=0;y<matrix.length;y++){
      for(let x=0;x<y;x++){
        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
      }
    }
    if(dir>0) matrix.forEach(row => row.reverse()); else matrix.reverse();
  }

  function playerRotate(){
    const m = current.matrix;
    rotate(m, 1);
    let offset = 1;
    while(collide(board, current)){
      current.pos.x += offset;
      offset = -(offset + (offset>0?1:-1));
      if(Math.abs(offset) > m[0].length){ rotate(m, -1); return; }
    }
  }

  function sweep(){
    let rowCount = 0;
    outer: for(let y=ROWS-1;y>=0;y--){
      for(let x=0;x<COLS;x++){ if(!board[y][x]) continue outer; }
      const row = board.splice(y,1)[0];
      board.unshift(new Array(COLS).fill(0));
      y++; rowCount++;
    }
    if(rowCount>0){
      const points = [0,40,100,300,1200];
      score += (points[rowCount] || 0) * level;
      lines += rowCount;
      level = Math.floor(lines / 10) + 1;
      dropInterval = Math.max(100, 1000 - (level-1)*80);
      scoreEl.textContent = score;
      linesEl.textContent = lines;
      levelEl.textContent = level;
      best = Math.max(best, score);
      bestEl.textContent = best;
      localStorage.setItem('tetrisBest', best);
      playSound('line');
    }
  }

  function playerDrop(){
    current.pos.y++;
    if(collide(board,current)){
      current.pos.y--;
      merge();
      resetPiece();
      sweep();
      canHold = true;
    }
    dropCounter = 0;
  }

  function hardDrop(){
    while(!collide(board,current)) current.pos.y++;
    current.pos.y--;
    merge();
    resetPiece();
    sweep();
    canHold = true;
    dropCounter = 0;
    playSound('drop');
  }

  function move(dir){
    current.pos.x += dir;
    if(collide(board,current)) current.pos.x -= dir;
  }

  function resetPiece(){
    current = next || createPiece(randomPiece());
    next = createPiece(randomPiece());
    if(collide(board,current)){
      // game over
      playing = false; statusEl.textContent = 'GAME OVER';
      playSound('gameover');
    }
  }

  function randomPiece(){
    return PIECE_KEYS[Math.floor(Math.random()*PIECE_KEYS.length)];
  }

  function update(time = 0){
    if(!playing || paused){ lastTime = time; requestAnimationFrame(update); return; }
    const delta = time - lastTime; lastTime = time; dropCounter += delta;
    if(dropCounter > dropInterval){ playerDrop(); }
    draw(); drawNext();
    requestAnimationFrame(update);
  }

  function startGame(){
    board = createMatrix(COLS, ROWS);
    score = 0; lines = 0; level = 1; dropInterval = 1000; playing = true; paused = false; canHold = true;
    next = createPiece(randomPiece()); current = createPiece(randomPiece());
    scoreEl.textContent=0; linesEl.textContent=0; levelEl.textContent=1; statusEl.textContent='PLAY';
    lastTime = 0; requestAnimationFrame(update);
    playSound('start');
  }

  function drawNext(){
    nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
    nctx.fillStyle = '#071827'; nctx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    if(!next) return;
    const size = next.matrix.length; const tile = Math.floor(nextCanvas.width / (size+1));
    const offsetX = Math.floor((nextCanvas.width - tile*size)/2);
    const offsetY = Math.floor((nextCanvas.height - tile*size)/2);
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        if(next.matrix[y][x]){
          nctx.fillStyle = next.color; nctx.fillRect(offsetX + x*tile + 4, offsetY + y*tile + 4, tile-8, tile-8);
        }
      }
    }
  }

  // Sound (very small beep) using WebAudio
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  function playSound(name){ if(!soundOn) return; try{ const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
    if(name==='drop'){ o.frequency.value = 150; g.gain.value=0.06; o.start(); setTimeout(()=>o.stop(),60); }
    else if(name==='line'){ o.frequency.value=400; g.gain.value=0.08; o.start(); setTimeout(()=>o.stop(),220); }
    else if(name==='gameover'){ o.frequency.value=80; g.gain.value=0.12; o.start(); setTimeout(()=>o.stop(),800); }
    else if(name==='start'){ o.frequency.value=600; g.gain.value=0.05; o.start(); setTimeout(()=>o.stop(),120); }
  }catch(e){/*ignore*/} }

  // Input
  document.addEventListener('keydown', e => {
    if(!playing && e.code==='Space'){ startGame(); }
    if(e.key==='p' || e.key==='P'){ paused = !paused; statusEl.textContent = paused? 'PAUSED' : 'PLAY'; }
    if(!playing || paused) return;
    if(e.key === 'ArrowLeft'){ move(-1); }
    else if(e.key === 'ArrowRight'){ move(1); }
    else if(e.key === 'ArrowDown'){ playerDrop(); }
    else if(e.key === 'ArrowUp'){ playerRotate(); }
    else if(e.code === 'Space'){ hardDrop(); }
  });

  // Buttons
  btnStart.addEventListener('click', ()=> startGame());
  btnPause.addEventListener('click', ()=>{ paused = !paused; statusEl.textContent = paused? 'PAUSED' : 'PLAY'; });
  btnHold.addEventListener('click', ()=>{
    if(!playing) return; if(!canHold) return;
    if(!hold){ hold = createPiece(current.type); current = next; next = createPiece(randomPiece()); }
    else { const t = hold.type; hold = createPiece(current.type); current = createPiece(t); }
    current.pos = {x:Math.floor(COLS/2)-1, y:0}; canHold = false; drawNext();
  });
  btnToggleSound.addEventListener('click', ()=>{ soundOn = !soundOn; btnToggleSound.textContent = soundOn? 'Sound On' : 'Sound Off'; });

  // touch buttons
  leftBtn.addEventListener('click', ()=>{ if(playing&&!paused) move(-1); });
  rightBtn.addEventListener('click', ()=>{ if(playing&&!paused) move(1); });
  downBtn.addEventListener('click', ()=>{ if(playing&&!paused) playerDrop(); });
  rotateBtn.addEventListener('click', ()=>{ if(playing&&!paused) playerRotate(); });

  // initial tiny draw
  draw();

  // expose to window for debugging
  window.tt = {startGame, board, createPiece};

})();
</script>
</body>
</html>
